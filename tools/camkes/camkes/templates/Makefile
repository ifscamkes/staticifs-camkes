#
# Copyright 2017, Data61
# Commonwealth Scientific and Industrial Research Organisation (CSIRO)
# ABN 41 687 119 230.
#
# This software may be distributed and modified according to the terms of
# the BSD 2-Clause license. Note that NO WARRANTY is provided.
# See "LICENSE_BSD2.txt" for details.
#
# @TAG(DATA61_BSD)
#

/*# Ignore the following line. It is intended to apply to the output of this
    template.
#*/
# THIS FILE IS AUTOMATICALLY GENERATED. YOUR EDITS WILL BE OVERWRITTEN.

/*# When modifying this template be particularly careful. The awkward syntax of
    both the templating language and GNU Make come together to make it very
    easy to introduce unreadable code in this context.
#*/

/*# Various macros to make constructing makefile rules easier. #*/
/*- macro rule_cp(target, dependencies) -*/
/*? target ?*/: /*? dependencies ?*/
	@echo " [CP] $(notdir $@)"
	${Q}mkdir -p $(dir $@)
	${Q}rm -f $@
	${Q}$(if $(or $(filter %.c,$<),$(filter %.h,$<),$(filter %.cpp,$<),$(filter %.hpp,$<),$(filter %.S,$<)),echo "#line 1 \"$<\"" >$@,)
	${Q}cat "$<" >>"$@"
/*- endmacro -*/

/*- macro rule_gen(target, dependencies, item, cfiles_append=None, hfiles_append=None, platform='seL4') -*/
/*- if cfiles_append is not none -*/
/*? cfiles_append ?*/_CFILES += /*? target ?*/
/*- endif -*/
/*- if hfiles_append is not none -*/
/*? hfiles_append ?*/_HFILES += /*? target ?*/
/*- endif -*/
/*? target ?*/: /*? dependencies ?*/
	@echo " [GEN] $(notdir $@)"
	${Q}mkdir -p $(dir $@)
	${Q}camkes.sh \
        ${CAMKES_FLAGS} \
        --file /*? options.file.name ?*/ \
        --item /*? item ?*/ \
        --outfile "$@" \
        --platform /*? platform ?*/
	# Reflow the generated file if it's a C source or header.
	${Q}$(if $(patsubst %.c,,$(patsubst %.h,,/*? target ?*/)),,${FMT} "$@" | ${SPONGE} "$@")
	# Reflow the generated file if it's an Isabelle theory.
	${Q}$(if $(patsubst %.thy,,/*? target ?*/),,${TPP} "$@" | ${SPONGE} "$@")
/*- endmacro -*/

# All targets need to be rebuilt if the source CAmkES descriptions change.
${TARGETS}: /*? ' '.join(imported) ?*/

# This Makefile itself needs to be rebuilt if the source CAmkES descriptions change.
${BUILD_DIR}/camkes-gen.mk: /*? ' '.join(imported) ?*/

/*- set instances = composition.instances -*/
/*- set connections = composition.connections -*/

/*# The terms 'group' and 'address space' are currently synonymous. We can
 *# derive the groups by collecting all the instances' address spaces.
 #*/
/*- set groups = set(map(lambda('x: x.address_space'), filter(lambda('x: not x.type.hardware'), instances))) -*/

# Generate the policy label mapping if the user requested it.
ifeq (${CONFIG_CAMKES_LABEL_MAPPING},y)
LABEL_MAPPING=$(abspath ${BUILD_DIR})/thy/CapDLLabels.thy
${TARGETS}: ${LABEL_MAPPING}
${LABEL_MAPPING}: /*? ' '.join(imported) ?*/ /*- for g in groups -*/ /*- set p = Perspective(group=g) -*/ ${SEL4_BINDIR}//*? p['elf_name'] ?*/ /*- endfor -*/
	@echo " [GEN] $(notdir $@)"
	$(Q)mkdir -p $(dir $@)
	$(Q)camkes.sh \
        ${CAMKES_FLAGS} \
        /*- for g in groups -*/ \
            /*- set p = Perspective(group=g) -*/ \
            --elf /*? p['elf_name'] ?*/ \
        /*- endfor -*/ \
        --file /*? options.file.name ?*/ \
        --item label-mapping \
        --outfile "$@" \
        --platform seL4
	${Q}${TPP} "$@" | ${SPONGE} "$@"
endif

# Static component files provided by the user.
/*- for i in instances if not i.type.hardware -*/
/*? i.name ?*/_CFILES += \
    $(/*? i.type.name ?*/_CFILES:%=$(abspath ${BUILD_DIR})/src//*? i.name ?*//static/%)
/*? i.name ?*/_CXXFILES += \
    $(/*? i.type.name ?*/_CXXFILES:%=$(abspath ${BUILD_DIR})/src//*? i.name ?*//static/%)
/*? i.name ?*/_OFILES += \
    $(/*? i.type.name ?*/_OFILES:%=$(abspath ${BUILD_DIR})/src//*? i.name ?*//static/%)
/*? i.name ?*/_ASMFILES += \
    $(/*? i.type.name ?*/_ASMFILES:%=$(abspath ${BUILD_DIR})/src//*? i.name ?*//static/%)
/*? i.name ?*/_HFILES += \
    $(/*? i.type.name ?*/_HFILES:%=$(abspath ${BUILD_DIR})/include//*? i.name ?*//static/%)
/*- if configuration[i.name].get('rump_config') -*/
/*? i.name ?*/_rumpbin += $(/*? i.type.name ?*/_rumpbin)
/*? i.name ?*/_CC := $(BASEFILE_CC)
/*- endif -*/
ifeq (${/*? i.name ?*/_CC}, )
/*? i.name ?*/_CC := ${CC}
endif

# This will be matched for local source and header files.
/*? rule_cp('$(abspath ${BUILD_DIR})/src/%s/static/%%' % i.name, '${SOURCE_DIR}/%') ?*/
/*? rule_cp('$(abspath ${BUILD_DIR})/include/%s/static/%%' % i.name, '${SOURCE_DIR}/%') ?*/

# This will be matched for global source and header files.
/*? rule_cp('$(abspath ${BUILD_DIR})/src/%s/static/%%' % i.name, '/%') ?*/
/*? rule_cp('$(abspath ${BUILD_DIR})/include/%s/static/%%' % i.name, '/%') ?*/

/*- endfor -*/

# Library dependencies required by glue code.
/*- for i in instances -*/
/*? i.name ?*/_instance_LIBS += ${/*? i.type.name ?*/_LIBS} ${CAMKES_CORE_LIBS}
/*- endfor -*/

# Instance entry point generation.
/*- for i in instances -*/
/*? rule_gen('$(abspath ${BUILD_DIR})/src/%s/generated/camkes.c' % i.name, ' '.join(imported), '%s/source' % i.name, i.name) ?*/
/*- if configuration[i.name].get('debug') -*/
    /*? rule_gen('$(abspath ${BUILD_DIR})/src/%s/generated/camkes.debug.c' % i.name, ' '.join(imported), '%s/debug' % i.name, i.name) ?*/
/*- endif -*/
/*- if configuration[i.name].get('simple') -*/
    /*? rule_gen('$(abspath ${BUILD_DIR})/src/%s/generated/camkes.simple.c' % i.name, ' '.join(imported), '%s/simple' % i.name, i.name) ?*/
/*- endif -*/
/*- if configuration[i.name].get('rump_config') -*/
    /*? rule_gen('$(abspath ${BUILD_DIR})/src/%s/generated/camkes.rumprun.c' % i.name, ' '.join(imported), '%s/rumprun' % i.name, i.name) ?*/
/*- endif -*/
/*? rule_gen('$(abspath ${BUILD_DIR})/include/%s/generated/camkes.h' % i.name, ' '.join(imported), '%s/header' % i.name) ?*/
/*- endfor -*/

# Connection code generation.
/*- for c in connections -*/
  /*- for id, e in enumerate(c.from_ends) -*/
/*? rule_gen('$(abspath ${BUILD_DIR})/src/%s/generated/%s_%s_%d.c' % (e.instance.name, e.interface.name, c.type.name, id), ' '.join(imported), '%s/from/source/%d' % (c.name, id), e.instance.name) ?*/

    /*# Add a rule to generate the header if this connector has a header template #*/
    /*- if lookup_template('%s/from/header' % c.name, c) is not none -*/
/*? rule_gen('$(abspath ${BUILD_DIR})/include/%s/generated/%s_%s_%d.h' % (e.instance.name, e.interface.name, c.type.name, id), ' '.join(imported), '%s/from/header/%d' % (c.name, id), hfiles_append=e.instance.name) ?*/
    /*- endif -*/

  /*- endfor -*/
  /*- for id, e in enumerate(c.to_ends) -*/
/*? rule_gen('$(abspath ${BUILD_DIR})/src/%s/generated/%s_%s_%d.c' % (e.instance.name, e.interface.name, c.type.name, id), ' '.join(imported), '%s/to/source/%d' % (c.name, id), e.instance.name) ?*/

    /*# Add a rule to generate the header if this connector has a header template #*/
    /*- if lookup_template('%s/to/header' % c.name, c) is not none -*/
/*? rule_gen('$(abspath ${BUILD_DIR})/include/%s/generated/%s_%s_%d.h' % (e.instance.name, e.interface.name, c.type.name, id), ' '.join(imported), '%s/to/header/%d' % (c.name, id), hfiles_append=e.instance.name) ?*/
    /*- endif -*/

  /*- endfor -*/

ifeq (${CONFIG_CAMKES_PRUNE_GENERATED},y)
/*# We need to provide specialised targets for the pruned c_pp files *and* o
 *# files so the generic targets in tools/common/camkes.mk won't match.
 #*/

/*# Pruned C files (from) #*/
  /*- for id, e in enumerate(c.from_ends) -*/
/*- set prefix = '$(abspath ${BUILD_DIR})/src/%s/generated/%s_%s_%d' % (e.instance.name, e.interface.name, c.type.name, id) -*/
/*? prefix ?*/.o: /*? prefix ?*/_pruned.c_pp
	@$(if $(filter-out 0,${V}),$(warning Using CAmkES generic .o target),)
	@echo " [CC] $(notdir $@)"
	$(Q)mkdir -p $(dir $@)
	$(Q)$(CC) -x c $(CFLAGS) $(foreach v,$(filter-out $<,$^),$(patsubst %,-I%,$(abspath $(dir ${v})))) -c $< -o $@
/*? prefix ?*/_pruned.c_pp: /*? prefix ?*/.c_pp
	@echo " [PRUNE] $(notdir $@)"
	${Q}LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${CONFIG_CAMKES_LLVM_PATH}/lib prune --keep /*? e.interface.name ?*/__run \
	/*- if e.interface in e.instance.type.emits -*/ \
	    --keep /*? e.interface.name ?*/_emit_underlying \
	/*- elif e.interface in e.instance.type.dataports -*/ \
	    --keep /*? e.interface.name ?*/_wrap_ptr \
	    --keep /*? e.interface.name ?*/_unwrap_ptr \
	    /*# XXX: When pruning generated code involving dataports, the attributes
	     *# of the dataport are discarded. This is a problem because dataports
	     *# need to be page-aligned for the shared memory remapping done by the
	     *# CapDL filters to work correctly. Here we reintroduce the necessary
	     *# attributes. Note that these are expected to match the original
	     *# attributes from whatever template you're using.
	     #*/ \
	    --add-attribute 'from_/*? id ?*/_/*? e.interface.name ?*/_data:aligned(1 << 12)' \
	    --add-attribute 'from_/*? id ?*/_/*? e.interface.name ?*/_data:section("shared_from_/*? id ?*/_/*? e.interface.name ?*/")' \
	/*- elif e.interface in e.instance.type.uses -*/ \
	    /*- for m in e.interface.type.methods -*/ \
	        --keep /*? e.interface.name ?*/_/*? m.name ?*/ \
	    /*- endfor -*/ \
	/*- endif -*/ \
	$(foreach i,${PRUNER_WHITELIST},--keep $i) \
	$(foreach i,${PRUNER_BLACKLIST},--blacklist $i) \
      --blacklist /*? e.interface.name ?*/_error_handler_fn \
      --output "$@" "$<"
	@# We prepend a declaration of abort because it gets pruned and is needed for
	@# verification.
	$(Q)sh -c "echo 'void abort(void);'; cat $@" | ${FMT} | ${SPONGE} "$@"
  /*- endfor -*/

/*# Pruned C files (to) #*/
  /*- for id, e in enumerate(c.to_ends) -*/
/*- set prefix = '$(abspath ${BUILD_DIR})/src/%s/generated/%s_%s_%d' % (e.instance.name, e.interface.name, c.type.name, id) -*/
/*? prefix ?*/.o: /*? prefix ?*/_pruned.c_pp
	@$(if $(filter-out 0,${V}),$(warning Using CAmkES generic .o target),)
	@echo " [CC] $(notdir $@)"
	$(Q)mkdir -p $(dir $@)
	$(Q)$(CC) -x c $(CFLAGS) $(foreach v,$(filter-out $<,$^),$(patsubst %,-I%,$(abspath $(dir ${v})))) -c $< -o $@
/*? prefix ?*/_pruned.c_pp: /*? prefix ?*/.c_pp
	@echo " [PRUNE] $(notdir $@)"
	${Q}LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${CONFIG_CAMKES_LLVM_PATH}/lib prune --keep /*? e.interface.name ?*/__run \
	/*- if e.interface in e.instance.type.consumes -*/ \
	    --keep /*? e.interface.name ?*/_poll \
	    --keep /*? e.interface.name ?*/_wait \
	/*- elif e.interface in e.instance.type.dataports -*/ \
	    --keep /*? e.interface.name ?*/_wrap_ptr \
	    --keep /*? e.interface.name ?*/_unwrap_ptr \
        /*# See note above. #*/ \
	    --add-attribute 'to_/*? id ?*/_/*? e.interface.name ?*/_data:aligned(1 << 12)' \
	    --add-attribute 'to_/*? id ?*/_/*? e.interface.name ?*/_data:section("shared_to_/*? id ?*/_/*? e.interface.name ?*/")' \
	/*- elif e.interface in e.instance.type.provides -*/ \
	    /*# nothing extra required #*/ \
	/*- endif -*/ \
	$(foreach i,${PRUNER_WHITELIST},--keep $i) \
	$(foreach i,${PRUNER_BLACKLIST},--blacklist $i) \
      --blacklist /*? e.interface.name ?*/_error_handler_fn \
      --output "$@" "$<"
	@# We prepend a declaration of abort because it gets pruned and is needed for
	@# verification.
	$(Q)sh -c "echo 'void abort(void);'; cat $@" | ${FMT} | ${SPONGE} "$@"
  /*- endfor -*/
endif

  /*- for e in c.from_ends -*/
/*# Theory generation #*/
/*- set fromthy = '$(abspath ${BUILD_DIR})/thy/%s/generated/%s.thy' % (e.instance.name, e.interface.name) -*/
/*? rule_gen(fromthy, ' '.join(imported), '%s/from/theory' % c.name, platform='autocorres') ?*/
ifeq (${CONFIG_CAMKES_THYS},y)
${TARGETS}: /*? fromthy ?*/
endif
  /*- endfor -*/

  /*- for e in c.to_ends -*/
/*- set tothy = '$(abspath ${BUILD_DIR})/thy/%s/generated/%s.thy' % (e.instance.name, e.interface.name) -*/
/*? rule_gen(tothy, ' '.join(imported), '%s/to/theory' % c.name, platform='autocorres') ?*/
ifeq (${CONFIG_CAMKES_THYS},y)
${TARGETS}: /*? tothy ?*/
endif
  /*- endfor -*/

/*- set unifiedthy = '$(abspath ${BUILD_DIR})/thy/%s/generated/%s.thy' % (c.name, c.name) -*/
/*# It's completely arbitrary that we've stuck the unified theory in the 'from'
 *# side of the template dictionary (see Template.py), but a quirk of CAmkES
 *# means connector-based templates need to be assigned to either the 'from' or
 *# 'to' side.
 #*/
/*? rule_gen(unifiedthy, ' '.join(imported), '%s/from/unifiedtheory' % c.name, platform='autocorres') ?*/
ifeq (${CONFIG_CAMKES_UNIFIED_THY},y)
${TARGETS}: /*? unifiedthy ?*/
endif
/*- if options.verbosity >= 2 -*/
  /*# With debugging on, the unified theory imports a base theory that we need
   *# to generate here.
   #*/
  /*- set unifiedbase = '$(abspath ${BUILD_DIR})/thy/%s/generated/%s_base.thy' % (c.name, c.name) -*/
/*? rule_gen(unifiedbase, ' '.join(imported), '%s/from/unifiedbase' % c.name, platform='autocorres') ?*/
ifeq (${CONFIG_CAMKES_UNIFIED_THY},y)
${TARGETS}: /*? unifiedbase ?*/
endif
/*- endif -*/

/*- if len(c.from_ends) == 1 and len(c.to_ends) == 1 -*/
# Unified version of the connector code.
/*- set prefix = '$(abspath ${BUILD_DIR})/thy/%s/generated/%s' % (c.name, c.name) -*/
/*? prefix ?*/.c: \
  /*? '$(abspath ${BUILD_DIR})/src/%s/generated/%s_%s_0.c' % (c.from_instance.name, c.from_interface.name, c.type.name) ?*/ \
  /*? '$(abspath ${BUILD_DIR})/src/%s/generated/%s_%s_0.c' % (c.to_instance.name, c.to_interface.name, c.type.name) ?*/
	@echo " [CAT] $(notdir $@)"
	$(Q)mkdir -p $(dir $@)
	${Q}cat >"$@" \
  /*? '$(abspath ${BUILD_DIR})/src/%s/generated/%s_%s_0.c' % (c.from_instance.name, c.from_interface.name, c.type.name) ?*/ \
  /*? '$(abspath ${BUILD_DIR})/src/%s/generated/%s_%s_0.c' % (c.to_instance.name, c.to_interface.name, c.type.name) ?*/
/*? prefix ?*/_pruned.c_pp: /*? prefix ?*/.c_pp
	@echo " [PRUNE] $(notdir $@)"
	${Q}LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${CONFIG_CAMKES_LLVM_PATH}/lib prune \
  --keep /*? c.to_interface.name ?*/__run \
  --keep /*? c.from_interface.name ?*/__run \
  /*- if c.from_interface in c.from_instance.type.emits -*/ \
    --keep /*? c.from_interface.name ?*/_emit_underlying \
  /*- elif c.from_interface in c.from_instance.type.dataports -*/ \
    --keep /*? c.from_interface.name ?*/_wrap_ptr \
    --keep /*? c.from_interface.name ?*/_unwrap_ptr \
  /*- elif c.from_interface in c.from_instance.type.uses -*/ \
    /*- for m in c.from_interface.type.methods -*/ \
      --keep /*? c.from_interface.name ?*/_/*? m.name ?*/ \
    /*- endfor -*/ \
  /*- endif -*/ \
  /*- if c.to_interface in c.to_instance.type.consumes -*/ \
    --keep /*? c.to_interface.name ?*/_poll \
    --keep /*? c.to_interface.name ?*/_wait \
  /*- elif c.to_interface in c.to_instance.type.dataports -*/ \
    --keep /*? c.to_interface.name ?*/_wrap_ptr \
    --keep /*? c.to_interface.name ?*/_unwrap_ptr \
  /*- elif c.to_interface in c.to_instance.type.provides -*/ \
    /*# nothing extra required #*/ \
  /*- endif -*/ \
  $(foreach i,${PRUNER_WHITELIST},--keep $i) \
  $(foreach i,${PRUNER_BLACKLIST},--blacklist $i) --output "$@" "$<" \
  --blacklist /*? c.to_interface.name ?*/_error_handler_fn \
  --blacklist /*? c.from_interface.name ?*/_error_handler_fn
	@echo " [FMT] $(notdir $@)"
	@# We prepend a declaration of abort because it gets pruned and is needed for
	@# verification.
	$(Q)sh -c "echo 'void abort(void);'; cat $@" | ${FMT} | ${SPONGE} "$@"
ifeq (${CONFIG_CAMKES_UNIFIED_THY},y)
${TARGETS}: /*? prefix ?*/_pruned.c_pp
endif
/*- endif -*/

/*- endfor -*/

# Architectural formalisation.
/*- set arch_thy = '$(abspath ${BUILD_DIR})/thy/ArchSpec.thy' -*/
/*? rule_gen(arch_thy, ' '.join(imported), 'arch-spec', platform='seL4') ?*/
ifeq (${CONFIG_CAMKES_ARCH_THY},y)
${TARGETS}: /*? arch_thy ?*/
endif

# Behavioural formalisation.
/*- set thy = '$(abspath ${BUILD_DIR})/thy/CimpBase.thy' -*/
/*? rule_gen(thy, ' '.join(imported), 'cimp-base', platform='seL4') ?*/
ifeq (${CONFIG_CAMKES_CIMP_THY},y)
${TARGETS}: /*? thy ?*/
endif

# Each component file may depend on the per-component generated header.
/*- for i in instances if not i.type.hardware -*/
    /*- set header = '$(abspath ${BUILD_DIR})/include/%s/generated/camkes.h' % i.name -*/
$(/*? i.name ?*/_CFILES:%.c=%.o): /*? header ?*/
$(/*? i.name ?*/_CXXFILES:%.cxx=%.o): /*? header ?*/
# In case we are running CPP separately:
$(/*? i.name ?*/_CFILES:%.c=%.c_pp): /*? header ?*/
/*- endfor -*/

# Each (generated or static) component file compilation may depend on the
# user-provided code.
/*- for i in instances if not i.type.hardware -*/
$(/*? i.name ?*/_CFILES:%.c=%.o): ${/*? i.name ?*/_HFILES} ${/*? i.name ?*/_CFILES} ${/*? i.name ?*/_CXXFILES} ${/*? i.name ?*/_ASMFILES}
$(/*? i.name ?*/_CXXFILES:%.cxx=%.o): ${/*? i.name ?*/_HFILES} ${/*? i.name ?*/_CFILES} ${/*? i.name ?*/_CXXFILES} ${/*? i.name ?*/_ASMFILES}
# In case we are running CPP separately:
$(/*? i.name ?*/_CFILES:%.c=%.c_pp): ${/*? i.name ?*/_HFILES} ${/*? i.name ?*/_CFILES} ${/*? i.name ?*/_ASMFILES}
/*- endfor -*/

# A target for each binary intended to match the one in common.mk. We introduce
# our own here because we (potentially) need to link different libraries for
# different components.
/*- for i in instances if not i.type.hardware -*/
/*? i.name ?*/_instance_LDFLAGS := \
    ${NK_LDFLAGS} \
    $(SEL4_LIBDIR:%=-L%) \
    ${CFLAGS} \
    ${STARTGROUP} \
    $(/*? i.name ?*/_instance_LIBS:%=-l%) \
    ${LIBGCC} \
    ${ENDGROUP} \
    -static -nostdlib \
    -u _camkes_start \
    -e _camkes_start \
    /*- for symbol in kept_symbols(i.name) -*/ -u /*? symbol ?*/ /*- endfor -*/ \
    -Wl,--script=$(abspath ${BUILD_DIR})/ld//*? i.name ?*//generated/linker.lds

/*? rule_gen('$(abspath ${BUILD_DIR})/ld/%s/generated/linker.lds' % i.name, ' '.join(imported), '%s/linker' % i.name) ?*/

/*# Only incrementally link if this instance is going on to become part of a
 *# group.
 #*/
/*- set grouped = [False] -*/
/*- for inst in instances if not i.type.hardware -*/
  /*- if id(i) != id(inst) and inst.address_space == i.address_space -*/
    /*- do grouped.__setitem__(0, True) -*/
  /*- endif -*/
/*- endfor -*/
/*- if grouped[0] -*/
/*? i.name ?*/_instance_LDFLAGS += -Wl,--relocatable
/*- endif -*/

CRTOBJFILES ?= $(SEL4_LIBDIR)/crt1.o $(SEL4_LIBDIR)/crti.o $(shell $(CC) $(CFLAGS) $(CPPFLAGS)  -print-file-name=crtbegin.o)
FINOBJFILES ?= $(shell $(CC) $(CFLAGS) $(CPPFLAGS) -print-file-name=crtend.o) $(SEL4_LIBDIR)/crtn.o

/*- set rump_config = configuration[i.name].get('rump_config') -*/
/*- if rump_config -*/
/*? i.name ?*/_instance_LDFLAGS += $(BASEFILE_LD_FLAGS) $(STARTGROUP) $(RUMPRUN_SEL4LIBS:%=-l%) $(ENDGROUP)

define /*? i.name ?*/_buildrump
	$(BASEFILE_OBJCOPY) /*? macros.format_list_of_strings("-G %s*", rump_config.get('interfaces_to_expose'), ' ') ?*/ $@
	mkdir -p $(@D)/rumprun/$(@F)_
	cp $@ $(@D)/rumprun/$(@F)_/rumprun.o
	RUMPRUN_BASEDIR=$(@D)/rumprun/$(@F)_ $(RUMPRUN_BAKE) /*? rump_config.get('rumprunbake_config') ?*/ $@ $(/*? i.name ?*/_rumpbin)
endef
/*- endif -*/

/*? i.name ?*/.instance.bin: $(/*? i.name ?*/_CFILES:%.c=%.o) \
                             $(/*? i.name ?*/_CXXFILES:%.cxx=%.o) \
                             $(/*? i.name ?*/_ASMFILES:%.S=%.o) \
                             $(/*? i.name ?*/_OFILES) \
                             /*- if rump_config -*/ $(/*? i.name ?*/_rumpbin) /*- endif -*/ \
                             /*- if rump_config -*/ $(INTERMEDIATE_BASEFILE) /*- endif -*/ \
                             $(/*? i.name ?*/_instance_LIBS:%=lib%.a) \
                             $(abspath ${BUILD_DIR})/ld//*? i.name ?*//generated/linker.lds
	@echo " [LD] $(notdir $@)"
	${Q}${/*? i.name ?*/_CC} $(CRTOBJFILES) $(filter %.o,$^) $(FINOBJFILES) ${/*? i.name ?*/_instance_LDFLAGS} -o $@
	$(/*? i.name ?*/_buildrump)

/*- set p = Perspective(group=i.address_space) -*/
/*? p['elf_name'] ?*/: /*? i.name ?*/.instance-copy.bin
/*# The actual recipe for the above target is generated below. Remember, groups
 *# and address spaces are essentially the same thing at this point.
 #*/
/*- endfor -*/

/*- for g in groups -*/
# Flags to use when linking /*? g ?*/. Note that we deliberately give groups a
# broken entry point so that, if they are incorrectly loaded without correct
# initial instruction pointers, threads will immediately fault.
/*? g ?*/_group_LDFLAGS += \
    ${NK_LDFLAGS} \
    $(CFLAGS:-flto= ) \
    -static -nostdlib \
    --entry=0x0
/*- endfor -*/

# CapDL generation. This assumes that the last element in TARGETS is a CapDL
# spec.
$(firstword ${TARGETS}): /*- for g in groups -*/ /*- set p = Perspective(group=g) -*/ ${SEL4_BINDIR}//*? p['elf_name'] ?*/ /*- endfor -*/
	@echo " [GEN] $(notdir $@)"
	$(Q)mkdir -p $(SEL4_BINDIR)
	$(Q)camkes.sh \
        ${CAMKES_FLAGS} \
        /*- for g in groups -*/ \
            /*- set p = Perspective(group=g) -*/ \
            --elf /*? p['elf_name'] ?*/ \
        /*- endfor -*/ \
        --file "${SOURCE_DIR}/${ADL}" \
        --item capdl \
        --outfile "$@" \
        --platform seL4

/*- for g in groups -*/
/*# This weird re-staging of everything in SEL4_BINDIR is here because the
 *# CapDL initialiser looks for the binaries it's going to boot here. It's
 *# awkward that we can't just tell it this information directly.
 #*/
/*- set p = Perspective(group=g) -*/
${SEL4_BINDIR}//*? p['elf_name'] ?*/: /*? p['elf_name'] ?*/
	${Q}mkdir -p "${SEL4_BINDIR}"
	@echo " [STAGE] $(notdir $@)"
	${Q} cp "$<" "$@"

/*? g ?*/_group_bin: # Dependencies for this are above.
	@if [ $(words $^) -eq 1 ]; then echo " [CP] $@"; else echo " [LD] $@"; fi
ifeq (${CONFIG_LINK_TIME_OPTIMISATIONS},y)
	@if [ $(words $^) -ne 1 ]; then echo "Warning: LTO will not be applied to $@" >&2; fi
endif
	${Q}if [ $(words $^) -eq 1 ]; then cp "$<" "$@"; else ${CC} $^ ${/*? g ?*/_group_LDFLAGS} -o $@; fi
/*- endfor -*/

# We need to apply objcopy to each component instance's ELF before we link them
# into a flattened binary in order to avoid symbol collision. Note that when we
# mangle symbols, we use the prefix 'camkes ' to avoid colliding with any
# user-provided symbols.
/*- set instancelist = set() -*/
/*- for i in instances if not i.type.hardware -*/
/*- set pre = NameMangling.Perspective(phase=NameMangling.TEMPLATES, instance=i.name, group=i.address_space) -*/
/*- set post = NameMangling.Perspective(phase=NameMangling.FILTERS, instance=i.name, group=i.address_space) -*/
/*? i.name ?*/.instance-copy.bin: /*? i.name ?*/.instance.bin
	@echo " [OBJCOPY] $@"
	# Brace yourself. This is going to be a bumpy ride.
	${OBJCOPY} \
        /*# Use a dummy impossible symbol of the empty string here, because
         *# marking one symbol as 'keep global' causes all others to be demoted
         *# to local. This allows us to avoid symbol collisions from
         *# user-provided symbols.
         #*/ \
        --keep-global-symbol "" \
        \
        /*# Rename the entry point to avoid symbol conflicts when we are
         *# colocated with other components. Note that we will still use this as
         *# the entry point.
         #*/ \
        --redefine-sym _camkes_start="/*? post['entry_symbol'] ?*/" \
        \
        /*# Rename the DMA pools so they don't collide. #*/ \
        --redefine-sym "/*? pre['dma_pool_symbol'] ?*/"="/*? post['dma_pool_symbol'] ?*/" \
        \
        /*# Rename shared memory symbols so they don't collide. While doing so,
         *# we update their information in the shared memory metadata so they
         *# can still be located by the CapDL filters.
         #*/ \
        /*- for mappings in shmem.values() -*/ \
            /*- set new_mappings = [] -*/ \
            /*- for local in mappings[i.name] -*/ \
                /*- set old_name = local[0] -*/ \
                /*- set new_name = 'camkes shmem %s %s' % (i.name, local[0]) -*/ \
                --redefine-sym "/*? old_name ?*/"="/*? new_name ?*/" \
                /*- do new_mappings.append((new_name, local[1], local[2])) -*/ \
            /*- endfor -*/ \
            /*- do mappings.__setitem__(i.name, new_mappings) -*/ \
        /*- endfor -*/ \
        \
        /*- for c in connections -*/ \
            \
            /*- if c.type.name == 'seL4DirectCall' -*/ \
                \
                /*# For all 'from' connection ends (calls to unresolved symbols),
                 *# rename the symbols so they will correctly link to the
                 *# implementations provided by the 'to' side.
                 #*/ \
                /*- for e in c.from_ends -*/ \
                    /*- if id(e.instance) == id(i) -*/ \
                        /*- for m in e.interface.type.methods -*/ \
                            --redefine-sym /*? e.interface.name ?*/_/*? m.name ?*/="camkes connection /*? e.parent.name ?*/_/*? m.name ?*/" \
                        /*- endfor -*/ \
                    /*- endif -*/ \
                /*- endfor -*/ \
                /*# For all 'to' connection ends (implementations of procedures),
                 *# rename the symbols so they will be found during the next
                 *# linking stage. Note we need to mark them as 'keep global' or
                 *# they will not be visible during the next link.
                 #*/ \
                /*- for e in c.to_ends -*/ \
                    /*- if id(e.instance) == id(i) -*/ \
                        /*- if '%s_%s' % (i.name, e.interface.name) in instancelist -*/ \
                            /*- continue -*/ \
                        /*- endif -*/ \
                        /*- do instancelist.add('%s_%s' % (i.name, e.interface.name)) -*/ \
                        /*- for m in e.interface.type.methods -*/ \
                            --redefine-sym /*? e.interface.name ?*/_/*? m.name ?*/="camkes connection /*? e.parent.name ?*/_/*? m.name ?*/" \
                            --keep-global-symbol "camkes connection /*? e.parent.name ?*/_/*? m.name ?*/" \
                        /*- endfor -*/ \
                    /*- endif -*/ \
                /*- endfor -*/ \
            /*- endif -*/ \
            \
        /*- endfor -*/ \
        /*? i.name ?*/.instance.bin $@
	@# Some toolchains insert exception handling infrastructure whether we ask
	@# for it or not. The preceding `objcopy` step breaks references in
	@# implicit `.eh_frame`s and friends, which then goes on to cause a linker
	@# warning. Rather than attempt some complicated gymnastics to repair these
	@# references, we just strip the exception handling pieces. To further
	@# complicate the process, some architectures require an `.eh_frame` and
	@# attempting to remove it causes errors. To handle this we just blindly
	@# try to remove it and mask errors. We can't do this unconditionally in
	@# the preceding `objcopy` because it fails when our toolchain has *not*
	@# inserted exception handling pieces or when we're targeting an
	@# architecture that requires `.eh_frame`.
	${Q}-${OBJCOPY} --remove-section .eh_frame --remove-section .eh_frame_hdr \
      --remove-section .rel.eh_frame --remove-section .rela.eh_frame $@ \
      >/dev/null 2>/dev/null
/*- endfor -*/
